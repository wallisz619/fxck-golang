# FXCK Go

### 工作区和GoPATH

GOROOT：Go语言安装根目录的路径，也就是Go语言的安装路径。
GOPATH：若干工作区目录的路径，也就是自己定义的工作空间。
GOBIN：Go生成可执行文件的路径。

### GOPATH的意义：
    1. GOPATH的目录下的每个目录都是一个工作空间。
    2. 每个工作空间的目录下都有两个目录，分别是src和bin。
    3. src目录下放Go语言的源文件，bin目录下放Go语言的可执行文件。
    4. 包管理 （在go mod下，GOPATH不再起作用）
    

### 构建和安装go程序的过程
    1. go build  
    2. go install

### Go 语言在多个工作区中查找依赖包的优先级：
    - Go Modules 模式（现代模式）：依赖优先级是本地缓存 > replace 指令 > vendor 目录 > 远程仓库。GOPATH 的工作区概念不再适用。
    - 传统 GOPATH 模式：依赖优先级是当前目录 > GOPATH 路径（按顺序） > 标准库。

### 如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗？
    1. 使用 Go Modules 模式，不会冲突。
        - Go Modules通过模块版本和go.mod文件，来明确指定依赖来源，不依赖GOPATH的多工作区查找机制。
    2. 使用传统 GOPATH 模式，可能会冲突。
        - Go 按照 GOPATH 中路径的顺序查找代码包（从左到右，或者从上到下）。如果多个工作区中存在相同导入路径的包，Go 会使用第一个工作区中找到的版本，而忽略后续的。
        - 如果两个工作区的包逻辑一致，程序能正常运行。
        - 如果这两个包的逻辑不同（比如接口或实现不一致），程序可能会表现出意料之外的行为，甚至出现编译错误。

### Go常用占位符
    - %v 是 Go 中的通用占位符，可以适用于任何数据类型。
    - %d, %x, %f 等用于格式化输出整数、十六进制、浮点数等常见类型。
    - %s, %q 常用于处理字符串类型。
    - %p 用于打印指针类型的值。

### 切片容量的增长
    1. 扩容 ：切片的容量会随着数据的增加而自动增长。 一般可以认为是 2 倍增长。
    2. 当原切片的长度（以下简称原长度）大于或等于1024时，Go 语言将会以原容量的1.25倍作为新容量的基准。

### 切片的底层数组
    1. 永远不会替换。只会生成新的。
    2. 在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。
    3. 它只是把新的切片作为了新底层数组的窗口，而没有对原切片，及其底层数组做任何改动。
    4. 请记住，在无需扩容时，append函数返回的是指向原底层数组的原切片，而在需要扩容时，append函数返回的是指向新底层数组的新切片。

### make vs new
    1. make创建的是切片，new创建的是指针。
    2. make创建的切片是引用类型，new创建的是值类型。
    3. make创建的切片是零值，new创建的是默认值。
    4. make创建的切片是动态分配的，new创建的是静态分配的。
    5. make 是专门用来创建 slice、map、channel 的值的。它返回的是被创建的值，并且立即可用。
    6. new 是申请一小块内存并标记它是用来存放某个值的。它返回的是一个指针，指向这一块内存的位置。
    